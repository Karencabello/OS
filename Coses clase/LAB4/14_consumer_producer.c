#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <pthread.h>

/*
Classic schema in concurrent programming.access

Some threads add data to be processed (from I/O, for instance), and leave them in a buffer
Others process the data, and remove from the buffer
*/

#define N 10

int buffer[N];           // Buffer to keep the data generated by the producer
int nBufferWithData = 0; // How many elements in the buffer have valid information
int finish = 0;
pthread_mutex_t lock;

int countN(int n){
    int tot = 0;
    for(int i =0; i < n; ++i)
        tot += i;
    return tot;
}

void * consumer(void*) {
    while(!finish) {
        pthread_mutex_lock(&lock);
        if (nBufferWithData > 0 && nBufferWithData <= N) { // no need to check that it is smaller than N, done in the producer
            int nBufferAtStart = nBufferWithData;
            // Obtains element on the buffer
            int r = buffer[nBufferWithData - 1];
            nBufferWithData -= 1;

            // Process it, by computing the summatory, could be any function
            int processed_r = countN(r);
            printf("After processing %d, I get %d Nbuffer = %d, NBuffer At start %d\n", 
                                r, processed_r, nBufferWithData, nBufferAtStart);
        }
        else {
            printf("Buffer empty %d \n", nBufferWithData);
        }
        pthread_mutex_unlock(&lock);

    }
}

void * producer(void *) {
    while(!finish) {
        // Check that the buffer is not full
        pthread_mutex_lock(&lock);
        usleep(1000);
        if (nBufferWithData < N){
            int r = rand() % 1000; // this can be any other way of generating info: read from I/O for instance
            printf("Writing in position %d\n", nBufferWithData);
            buffer[nBufferWithData] = r;
            nBufferWithData += 1;
        }
        else {
            printf("Full buffer %d\n", nBufferWithData);
        }
        pthread_mutex_unlock(&lock);

    }
}

#define N_CONSUMERS 3
#define N_PRODUCERS 2
int main(int argc, char* argv[]) {
    pthread_mutex_init(&lock, NULL);
    pthread_t tid_consumer[N_CONSUMERS];
    pthread_t tid_producer[N_PRODUCERS];
    for (int i = 0; i < N_CONSUMERS; ++i) {
        pthread_create(&tid_consumer[i], NULL, consumer, NULL);
    }
    for (int i = 0; i < N_PRODUCERS; ++i) {
        pthread_create(&tid_producer[i], NULL, producer, NULL);
    }

    for (int i = 0; i < N_CONSUMERS; ++i) {
        pthread_join(tid_consumer[i], NULL);
    }
    for (int i = 0; i < N_PRODUCERS; ++i) {
        pthread_join(tid_producer[i], NULL);
    }
}